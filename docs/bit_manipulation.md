# 비트조작
### 부울 연산자

1.  AND : 이항 연산자로, 둘 다 True인 경우에만 연산 결과가 True 
2.  OR : 이항 연산자로, 둘 중 하나라도 True라면 연산 결과가 True 
3.  NOT : 단항 연산자로, True이면 False로 False이면 True 
4.  XOR : 두 값의 각 자릿수를 비교해, 값이 같으면 0, 다르면 1을 계산

### 비트 연산자

![20211017_003415](https://user-images.githubusercontent.com/53229888/137593639-4743a5ea-bd11-4e0f-b2fe-c52c3aae655a.png)

1.  & : 동일한 위치의 bit가 모두 1인 경우에만 연산결과 1, 그 외의 경우 0
2.  | : 동일한 위치의 bit 중 하나라도 1인 경우에 연산결과 1, 그 외의 경우 0
3.  ^ : 동일한 위치의 bit가 다르다면 1, 동일하다면 0
4.  ~: 동일한 위치의 bit가 다르면 반대되는 값으로 출력

### SHIFT 연산 (>>, <<)

-   a << b는 a의 비트를 b칸 만큼 왼쪽으로 밀어 내는 것이고, a >> b는 a의 비트를 b칸 만큼 오른쪽으로 밀어내는 것

```
bin(0b0010 << 2)  # 0b1000
bin(0b1100 >> 2)  # 0b11
```

#### 비트 마스크(bitMask)

비트마스크는 알고리즘 이라기 보단 테크닉에 가깝다. 비트는 컴퓨터에서 다루는 최소 단위이며, 정수를 이진수로 표현, 비트 연산을 통해 문제를 해결해 나가는 기술을 비트마스크 라고 합니다.

-   **비트연산**을 통한 삽입, 삭제, 조회 등이 간단해짐
-   **더 간결한 코드** 작성이 가능
-   **더 빠른 연산**이 가능
-   **비트마스크**를 이용한 정수 표현으로 **다이나믹 프로그래밍**이 가능함. (중요)

### 2의 보수

-   보수라는 개념은 **음수를 표기하기 위해 등장한 개념**
-   2진수에서 2의 보수( two's complement )는 **음수**를 나타낸다  
      
      
    

**2의 보수 수학 연산**

1\. 비트 연산자 NOT은 2의 보수에서 1을 뺀것이고,

2\. 2의 보수 수학 연산은 비트연산자 NOT에서 1을 더한것이다.

(2의 보수 연산)= (NOT 연산)+1

(NOT 연산) = (2의 보수 연산)-1

**비트연산자 NOT**

NOT x = -x-1인 이유

예시) 4비트라고 가정할때 0111의 not은 1000이다. 이둘을  변환했을때

0111 =7, 1000= -8이 되는것을 알 수 있다.

참고자료

[https://youtu.be/yHBYeguDR0A](https://youtu.be/yHBYeguDR0A)
